///|
/// 通知前端在指定位置放置一个战斗铜偶（前端渲染消息）
///
/// 该函数用于通知前端在3D场景中的指定位置渲染一个战斗铜偶。函数会将铜偶的
/// 完整信息（包括属性、状态等）序列化为JSON并发送到前端，前端根据消息内容
/// 在对应位置创建并显示铜偶的3D模型。
///
/// 参数说明：
/// - copper: 要放置的战斗铜偶实例，包含所有战斗状态和属性信息
/// - id: 铜偶的唯一标识符，用于前端识别和管理
/// - position: 铜偶在地图上的位置坐标 (x, y)
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "set_copper"（消息类型标识）
/// - content: JSON字符串，包含 id、position 和 copper 的完整JSON数据
///
/// 使用场景：
/// - 游戏开始时放置初始铜偶
/// - 需要在前端显示铜偶时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 铜偶数据会被完整序列化，包含所有战斗状态
/// - 前端需要根据 position 在3D场景中正确定位铜偶
fn set_copper(copper : BattleCopper, id : Int, position : (Int, Int)) -> Unit {
  msg_info.broadcast({
    type_msg: "set_copper",
    content: (
      { "id": id, "position": position, "copper": copper.to_json() } : Json).stringify(),
  })
}

///|
/// 通知前端在指定位置放置一个敌人（前端渲染消息）
///
/// 该函数用于通知前端在3D场景中的指定位置渲染一个敌人。函数会将敌人的
/// 完整信息（包括属性、状态等）序列化为JSON并发送到前端，前端根据消息内容
/// 在对应位置创建并显示敌人的3D模型。注意：敌人可以是野生敌人，也可以是
/// 玩家召唤的友方召唤物。
///
/// 参数说明：
/// - enemy: 要放置的敌人实例，包含所有战斗状态和属性信息
/// - id: 敌人的唯一标识符，用于前端识别和管理
/// - position: 敌人在地图上的位置坐标 (x, y)
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "set_enemy"（消息类型标识）
/// - content: JSON字符串，包含 id、position 和 enemy 的完整JSON数据
///
/// 使用场景：
/// - 房间生成时放置敌人
/// - 召唤友方召唤物时
/// - 回合结束时生成新敌人时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 敌人数据会被完整序列化，包含所有战斗状态
/// - 前端需要根据 position 在3D场景中正确定位敌人
/// - 友方召唤物和野生敌人使用相同的渲染系统
fn set_enemy(enemy : Enemy, id : Int, position : (Int, Int)) -> Unit {
  msg_info.broadcast({
    type_msg: "set_enemy",
    content: (
      { "id": id, "position": position, "enemy": enemy.to_json() } : Json).stringify(),
  })
}

///|
/// 通知前端在指定位置放置一个建筑（前端渲染消息）
///
/// 该函数用于通知前端在3D场景中的指定位置渲染一个建筑。函数会将建筑的
/// 完整信息（包括属性、状态、资源类型等）序列化为JSON并发送到前端，前端
/// 根据消息内容在对应位置创建并显示建筑的3D模型。建筑可以是玩家建造的
/// （如防御塔、矿钻），也可以是房间生成的（如充能线圈）。
///
/// 参数说明：
/// - structure: 要放置的建筑实例，包含所有状态和属性信息
/// - id: 建筑的唯一标识符，用于前端识别和管理
/// - position: 建筑在地图上的位置坐标 (x, y)
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "set_structure"（消息类型标识）
/// - content: JSON字符串，包含 id、position 和 structure 的完整JSON数据
///
/// 使用场景：
/// - 玩家建造建筑时
/// - 房间生成时放置建筑（如充能线圈）
/// - 需要在前端显示建筑时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 建筑数据会被完整序列化，包含所有状态和资源类型
/// - 前端需要根据 position 在3D场景中正确定位建筑
/// - 矿钻建筑需要根据 resource_type 显示不同的资源类型
fn set_structure(
  structure : Structure,
  id : Int,
  position : (Int, Int),
) -> Unit {
  msg_info.broadcast({
    type_msg: "set_structure",
    content: (
      { "id": id, "position": position, "structure": structure.to_json() } :
      Json).stringify(),
  })
}

///|
/// 通知前端在指定位置放置一个材料（前端渲染消息）
///
/// 该函数用于通知前端在3D场景中的指定位置渲染一个可收集的材料物品。函数会将
/// 材料的完整信息（包括名称、资源类型、模型路径等）序列化为JSON并发送到前端，
/// 前端根据消息内容在对应位置创建并显示材料的3D模型。材料可以被玩家收集并
/// 转换为资源。
///
/// 参数说明：
/// - material: 要放置的材料实例，包含所有基础信息
/// - id: 材料的唯一标识符，用于前端识别和管理
/// - position: 材料在地图上的位置坐标 (x, y)
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "set_material"（消息类型标识）
/// - content: JSON字符串，包含 id、position 和 material 的完整JSON数据
///
/// 使用场景：
/// - 房间生成时随机放置材料
/// - 需要在前端显示可收集材料时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 材料数据会被完整序列化，包含资源类型和模型路径
/// - 前端需要根据 position 在3D场景中正确定位材料
/// - 材料收集后需要调用 remove_unit 移除显示
fn set_material(material : Material, id : Int, position : (Int, Int)) -> Unit {
  msg_info.broadcast({
    type_msg: "set_material",
    content: (
      { "id": id, "position": position, "material": material.to_json() } : Json).stringify(),
  })
}

///|
/// 通知前端删除一个单位（带删除动画）
///
/// 该函数用于通知前端删除3D场景中的指定单位。函数会发送删除消息到前端，
/// 前端应该播放删除动画（如缓缓消失、淡出等），然后从场景中移除该单位。
/// 单位可以是铜偶、敌人、建筑或材料。
///
/// 参数说明：
/// - id: 要删除的单位的唯一标识符
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "remove_unit"（消息类型标识）
/// - content: JSON字符串，包含 id
///
/// 使用场景：
/// - 单位被击杀时（铜偶、敌人、建筑）
/// - 材料被收集时
/// - 需要从场景中移除单位时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 前端应该播放删除动画，提升游戏体验
/// - 动画播放完成后才真正移除单位
/// - 确保在发送删除消息前，后端已经清理了单位的所有状态
fn remove_unit(id : Int) -> Unit {
  msg_info.broadcast({
    type_msg: "remove_unit",
    content: ({ "id": id } : Json).stringify(),
  })
}

///|
/// 单位朝向枚举（基本方向）
///
/// 该枚举定义了单位在3D场景中的基本朝向，包括四个基本方向。这些方向用于
/// 控制单位模型的旋转，使其面向正确的方向。注意：这是简化的方向系统，只包含
/// 基本方向，不包含对角线方向。
///
/// 枚举值：
/// - PositiveX: 正X方向（向右）
/// - NegativeX: 负X方向（向左）
/// - PositiveY: 正Y方向（向前）
/// - NegativeY: 负Y方向（向后）
priv enum UnitDirection {
  PositiveX
  NegativeX
  PositiveY
  NegativeY
} derive(Show)

///|
/// 通知前端改变一个单位的朝向（前端动画消息）
///
/// 该函数用于通知前端改变3D场景中指定单位的朝向。函数会将新的朝向信息发送
/// 到前端，前端应该旋转单位模型，使其面向指定的方向。朝向改变通常发生在
/// 单位移动时，单位会面向移动方向。
///
/// 参数说明：
/// - id: 要改变朝向的单位的唯一标识符
/// - direction: 新的朝向方向（UnitDirection枚举值）
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "change_direction"（消息类型标识）
/// - content: JSON字符串，包含 id 和 direction（转换为字符串）
///
/// 使用场景：
/// - 单位移动后改变朝向
/// - 需要调整单位朝向时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 前端应该平滑旋转单位模型，而不是瞬间改变
/// - 方向是基本方向，不包含对角线
/// - 确保在移动后调用，使单位面向移动方向
fn change_direction(id : Int, direction : UnitDirection) -> Unit {
  msg_info.broadcast({
    type_msg: "change_direction",
    content: ({ "id": id, "direction": direction.to_string() } : Json).stringify(),
  })
}

///|
/// 通知前端移动一个单位到指定位置（前端动画消息）
///
/// 该函数用于通知前端在3D场景中移动指定单位到新的位置。函数会将目标位置
/// 发送到前端，前端应该播放移动动画（如平滑移动、路径动画等），将单位从
/// 当前位置移动到目标位置。单位可以是铜偶、敌人或友方召唤物。
///
/// 参数说明：
/// - id: 要移动的单位的唯一标识符
/// - position: 目标位置坐标 (x, y)
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "move_to"（消息类型标识）
/// - content: JSON字符串，包含 id 和 to（目标位置）
///
/// 使用场景：
/// - 玩家移动铜偶时
/// - 玩家移动友方召唤物时
/// - 敌人AI移动时
/// - 需要移动单位到新位置时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 前端应该播放平滑的移动动画，提升游戏体验
/// - 移动动画应该考虑路径和障碍物
/// - 确保在更新后端位置后调用，保持前后端同步
fn move_to(id : Int, position : (Int, Int)) -> Unit {
  msg_info.broadcast({
    type_msg: "move_to",
    content: ({ "id": id, "to": position } : Json).stringify(),
  })
}

///|
/// 通知前端显示或隐藏单位的可移动状态指示器（绿色圈圈）
///
/// 该函数用于通知前端在单位脚下显示或隐藏可移动状态指示器（绿色圈圈）。
/// 当 can_move 为 true 时，前端应该在单位脚下显示绿色圈圈，表示该单位
/// 本回合可以移动；当 can_move 为 false 时，前端应该清除绿色圈圈。
/// 注意：绿色圈圈可以与红色圈圈（可攻击）和黄色圈圈（可召唤）叠加显示。
///
/// 参数说明：
/// - id: 要更新状态的单位的唯一标识符
/// - can_move: 是否可移动（true = 显示绿色圈圈，false = 清除绿色圈圈）
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "display_can_move"（消息类型标识）
/// - content: JSON字符串，包含 id 和 can_move（转换为字符串）
///
/// 使用场景：
/// - 回合开始时更新单位状态
/// - 单位移动后更新状态
/// - 需要显示单位可移动状态时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 绿色圈圈应该显示在单位脚下，表示可移动状态
/// - 可以与红色圈圈（可攻击）和黄色圈圈（可召唤）叠加显示
/// - 状态改变时应该平滑过渡，避免突兀
fn display_can_move(id : Int, can_move : Bool) -> Unit {
  msg_info.broadcast({
    type_msg: "display_can_move",
    content: ({ "id": id, "can_move": can_move.to_string() } : Json).stringify(),
  })
}

///|
/// 通知前端显示或隐藏单位的可攻击状态指示器（红色圈圈）
///
/// 该函数用于通知前端在单位脚下显示或隐藏可攻击状态指示器（红色圈圈）。
/// 当 can_attack 为 true 时，前端应该在单位脚下显示红色圈圈，表示该单位
/// 本回合可以攻击；当 can_attack 为 false 时，前端应该清除红色圈圈。
/// 注意：红色圈圈可以与绿色圈圈（可移动）和黄色圈圈（可召唤）叠加显示。
///
/// 参数说明：
/// - id: 要更新状态的单位的唯一标识符
/// - can_attack: 是否可攻击（true = 显示红色圈圈，false = 清除红色圈圈）
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "display_can_attack"（消息类型标识）
/// - content: JSON字符串，包含 id 和 can_attack（转换为字符串）
///
/// 使用场景：
/// - 回合开始时更新单位状态
/// - 单位攻击后更新状态
/// - 需要显示单位可攻击状态时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 红色圈圈应该显示在单位脚下，表示可攻击状态
/// - 可以与绿色圈圈（可移动）和黄色圈圈（可召唤）叠加显示
/// - 状态改变时应该平滑过渡，避免突兀
fn display_can_attack(id : Int, can_attack : Bool) -> Unit {
  msg_info.broadcast({
    type_msg: "display_can_attack",
    content: ({ "id": id, "can_attack": can_attack.to_string() } : Json).stringify(),
  })
}

///|
/// 通知前端显示或隐藏单位的可召唤状态指示器（黄色圈圈）
///
/// 该函数用于通知前端在单位脚下显示或隐藏可召唤状态指示器（黄色圈圈）。
/// 当 can_summon 为 true 时，前端应该在单位脚下显示黄色圈圈，表示该单位
/// （通常是共鸣者铜偶）本回合可以召唤；当 can_summon 为 false 时，前端应该
/// 清除黄色圈圈。注意：黄色圈圈可以与绿色圈圈（可移动）和红色圈圈（可攻击）叠加显示。
///
/// 参数说明：
/// - id: 要更新状态的单位的唯一标识符（通常是共鸣者铜偶）
/// - can_summon: 是否可召唤（true = 显示黄色圈圈，false = 清除黄色圈圈）
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "display_can_summon"（消息类型标识）
/// - content: JSON字符串，包含 id 和 can_summon（转换为字符串）
///
/// 使用场景：
/// - 回合开始时更新单位状态（共鸣者铜偶）
/// - 单位召唤后更新状态
/// - 需要显示单位可召唤状态时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 黄色圈圈应该显示在单位脚下，表示可召唤状态
/// - 可以与绿色圈圈（可移动）和红色圈圈（可攻击）叠加显示
/// - 只有共鸣者类型的铜偶才会有可召唤状态
/// - 状态改变时应该平滑过渡，避免突兀
fn display_can_summon(id : Int, can_summon : Bool) -> Unit {
  msg_info.broadcast({
    type_msg: "display_can_summon",
    content: ({ "id": id, "can_summon": can_summon.to_string() } : Json).stringify(),
  })
}

///|
/// 通知前端显示或隐藏单位的可建造状态指示器（蓝色圈圈）
///
/// 该函数用于通知前端在单位脚下显示或隐藏可建造状态指示器（蓝色圈圈）。
/// 当 can_build 为 true 时，前端应该在单位脚下显示蓝色圈圈，表示该单位
/// （通常是工匠铜偶）本回合可以建造；当 can_build 为 false 时，前端应该
/// 清除蓝色圈圈。注意：蓝色圈圈可以与绿色圈圈（可移动）、红色圈圈（可攻击）
/// 和黄色圈圈（可召唤）叠加显示。
///
/// 参数说明：
/// - id: 要更新状态的单位的唯一标识符（通常是工匠铜偶）
/// - can_build: 是否可建造（true = 显示蓝色圈圈，false = 清除蓝色圈圈）
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "display_can_build"（消息类型标识）
/// - content: JSON字符串，包含 id 和 can_build（转换为字符串）
///
/// 使用场景：
/// - 回合开始时更新单位状态（工匠铜偶）
/// - 单位建造后更新状态
/// - 需要显示单位可建造状态时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 蓝色圈圈应该显示在单位脚下，表示可建造状态
/// - 可以与其他状态圈圈叠加显示（绿色、红色、黄色）
/// - 只有工匠类型的铜偶才会有可建造状态
/// - 状态改变时应该平滑过渡，避免突兀
fn display_can_build(id : Int, can_build : Bool) -> Unit {
  msg_info.broadcast({
    type_msg: "display_can_build",
    content: ({ "id": id, "can_build": can_build.to_string() } : Json).stringify(),
  })
}

///|
/// 通知前端清除单位的所有状态指示器（清除所有圈圈）
///
/// 该函数用于通知前端清除指定单位的所有状态指示器（绿色、红色、黄色、蓝色圈圈）。
/// 函数会发送清除消息到前端，前端应该移除单位脚下的所有状态圈圈，使单位
/// 回到无状态显示的状态。这通常用于状态重置或单位被移除时。
///
/// 参数说明：
/// - id: 要清除状态的单位的唯一标识符
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "clear_state"（消息类型标识）
/// - content: JSON字符串，包含 id
///
/// 使用场景：
/// - 单位状态更新前清除旧状态
/// - 单位被移除前清除状态
/// - 需要重置单位状态显示时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 会清除所有状态圈圈（可移动、可攻击、可召唤、可建造）
/// - 清除后单位应该回到无状态显示的状态
/// - 通常在更新状态前调用，避免状态叠加
fn clear_state(id : Int) -> Unit {
  msg_info.broadcast({
    type_msg: "clear_state",
    content: ({ "id": id } : Json).stringify(),
  })
}

///|
/// 通知前端将摄像机视角聚焦到指定单位（摄像机动画）
///
/// 该函数用于通知前端将3D场景的摄像机视角聚焦到指定单位。函数会发送动画消息
/// 到前端，前端应该平滑移动摄像机，使其聚焦到目标单位，让玩家能够清楚地看到
/// 该单位的行动。这通常用于单位执行重要操作时（如攻击、移动），提升游戏体验。
///
/// 参数说明：
/// - id: 要聚焦的单位的唯一标识符
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "animate_move"（消息类型标识）
/// - content: JSON字符串，包含 id
///
/// 使用场景：
/// - 单位执行攻击时聚焦到攻击单位
/// - 单位执行移动时聚焦到移动单位
/// - 需要让玩家关注某个单位时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 摄像机应该平滑移动，而不是瞬间跳转
/// - 聚焦后应该保持一段时间，让玩家看清操作
/// - 使用全局消息系统（@global_msg），确保所有客户端同步
fn animate_move(id : Int) -> Unit {
  @global_msg.msg_info.broadcast({
    type_msg: "animate_move",
    content: ({ "id": id } : Json).stringify(),
  })
}

///|
/// 通知前端将摄像机视角复位到默认位置（摄像机动画）
///
/// 该函数用于通知前端将3D场景的摄像机视角复位到默认位置。函数会发送复位消息
/// 到前端，前端应该平滑移动摄像机，使其回到默认的全局视角，让玩家能够看到
/// 整个地图。这通常用于回合结束时，让玩家看到全局状态。
///
/// 参数说明：
/// - 无参数
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "animate_reset"（消息类型标识）
/// - content: JSON字符串，空对象
///
/// 使用场景：
/// - 回合结束时复位视角
/// - 需要显示全局视角时
/// - 需要重置摄像机位置时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 摄像机应该平滑移动，而不是瞬间跳转
/// - 复位后应该显示全局视角，让玩家看到整个地图
/// - 通常在回合结束时调用，让玩家看到全局状态
fn animate_reset() -> Unit {
  msg_info.broadcast({
    type_msg: "animate_reset",
    content: ({} : Json).stringify(),
  })
}

///|
/// 通知前端在指定位置放置一个地图块（地板渲染）
///
/// 该函数用于通知前端在3D场景中的指定位置渲染一个地图块（地板）。地图块是
/// 游戏地图的基础元素，表示单位可以移动和站立的位置。地图块通常设计为灰色，
/// 作为游戏地图的视觉基础。注意：此函数用于单个地图块，批量放置应使用 put_room_blocks。
///
/// 参数说明：
/// - position: 地图块的位置坐标 (x, y)
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "put_map_block"（消息类型标识）
/// - content: JSON字符串，包含 position
///
/// 使用场景：
/// - 需要单独放置地图块时
/// - 地图扩展时添加新地块
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 地图块通常设计为灰色，作为视觉基础
/// - 地图块表示可移动区域，单位可以站在上面
/// - 批量放置时建议使用 put_room_blocks 优化性能
fn put_map_block(position : (Int, Int)) -> Unit {
  msg_info.broadcast({
    type_msg: "put_map_block",
    content: ({ "position": position } : Json).stringify(),
  })
}

///|
/// 通知前端批量放置地图块（优化性能，一次性创建整个房间的地板）
///
/// 该函数用于通知前端在3D场景中批量渲染地图块（地板）。函数会发送批量放置
/// 消息到前端，前端应该一次性创建整个房间的地板，而不是逐个创建。这可以
/// 显著提升性能，特别是在生成新房间时。房间通常是9x9的网格，包含81个地图块。
///
/// 参数说明：
/// - room_position: 房间的索引位置坐标 (x, y)，表示房间在地图上的位置
/// - size: 房间的大小（通常是9，表示9x9的房间）
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "put_room_blocks"（消息类型标识）
/// - content: JSON字符串，包含 room_position 和 size
///
/// 使用场景：
/// - 生成新房间时批量创建地板
/// - 需要优化性能时使用批量放置
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 批量放置可以显著提升性能，避免逐个创建
/// - 房间大小通常是9（9x9网格）
/// - 前端应该根据 room_position 和 size 计算所有地图块位置
fn put_room_blocks(room_position : (Int, Int), size : Int) -> Unit {
  msg_info.broadcast({
    type_msg: "put_room_blocks",
    content: ({ "room_position": room_position, "size": size } : Json).stringify(),
  })
}

///|
/// 通知前端将指定地图块设置为可移动状态（绿色高亮）
///
/// 该函数用于通知前端将指定位置的地图块渲染为绿色，表示该位置是单位的可移动
/// 范围。当玩家点击移动按钮时，所有可移动的位置会显示为绿色，帮助玩家直观地
/// 看到可以移动到哪些位置。绿色是移动范围的视觉标识。
///
/// 参数说明：
/// - position: 要设置为可移动状态的地图块位置坐标 (x, y)
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "set_move_block"（消息类型标识）
/// - content: JSON字符串，包含 position
///
/// 使用场景：
/// - 玩家点击移动按钮时显示移动范围
/// - 需要高亮可移动位置时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 地图块应该渲染为绿色，表示可移动状态
/// - 绿色是移动范围的视觉标识，区别于攻击范围（红色）和召唤范围（黄色）
/// - 移动结束后应该调用 clear_block 清除高亮
fn set_move_block(position : (Int, Int)) -> Unit {
  msg_info.broadcast({
    type_msg: "set_move_block",
    content: ({ "position": position } : Json).stringify(),
  })
}

///|
/// 通知前端将指定地图块设置为可攻击状态（红色高亮）
///
/// 该函数用于通知前端将指定位置的地图块渲染为红色，表示该位置是单位的可攻击
/// 目标。当玩家点击攻击按钮时，所有可攻击目标的位置会显示为红色，帮助玩家
/// 直观地看到可以攻击哪些目标。红色是攻击范围的视觉标识。
///
/// 参数说明：
/// - position: 要设置为可攻击状态的地图块位置坐标 (x, y)
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "set_attack_block"（消息类型标识）
/// - content: JSON字符串，包含 position
///
/// 使用场景：
/// - 玩家点击攻击按钮时显示攻击范围
/// - 需要高亮可攻击目标时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 地图块应该渲染为红色，表示可攻击状态
/// - 红色是攻击范围的视觉标识，区别于移动范围（绿色）和召唤范围（黄色）
/// - 攻击结束后应该调用 clear_block 清除高亮
fn set_attack_block(position : (Int, Int)) -> Unit {
  msg_info.broadcast({
    type_msg: "set_attack_block",
    content: ({ "position": position } : Json).stringify(),
  })
}

///|
/// 通知前端将指定地图块设置为可召唤/建造状态（黄色高亮）
///
/// 该函数用于通知前端将指定位置的地图块渲染为黄色，表示该位置是单位的可召唤
/// 或可建造范围。当玩家点击召唤或建造按钮时，所有可召唤/建造的位置会显示为
/// 黄色，帮助玩家直观地看到可以在哪些位置召唤单位或建造建筑。注意：召唤范围
/// 和建造范围共用此函数和黄色标识。
///
/// 参数说明：
/// - position: 要设置为可召唤/建造状态的地图块位置坐标 (x, y)
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "set_can_summon_blocks"（消息类型标识）
/// - content: JSON字符串，包含 position
///
/// 使用场景：
/// - 玩家点击召唤按钮时显示召唤范围
/// - 玩家点击建造按钮时显示建造范围
/// - 需要高亮可召唤/建造位置时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 地图块应该渲染为黄色，表示可召唤/建造状态
/// - 黄色是召唤/建造范围的视觉标识，区别于移动范围（绿色）和攻击范围（红色）
/// - 召唤/建造结束后应该调用 clear_block 清除高亮
/// - 召唤范围和建造范围共用此函数和显示系统
fn set_can_summon_blocks(position : (Int, Int)) -> Unit {
  msg_info.broadcast({
    type_msg: "set_can_summon_blocks",
    content: ({ "position": position } : Json).stringify(),
  })
}

///|
/// 通知前端将指定地图块设置为可建造状态（蓝色高亮）
///
/// 该函数用于通知前端将指定位置的地图块渲染为蓝色，表示该位置是单位的可建造
/// 范围。当玩家点击建造按钮时，所有可建造的位置会显示为蓝色，帮助玩家直观地
/// 看到可以在哪些位置建造建筑。注意：目前建造范围也使用黄色（set_can_summon_blocks），
/// 此函数可能未完全使用。
///
/// 参数说明：
/// - position: 要设置为可建造状态的地图块位置坐标 (x, y)
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "set_build_blocks"（消息类型标识）
/// - content: JSON字符串，包含 position
///
/// 使用场景：
/// - 玩家点击建造按钮时显示建造范围（如果使用蓝色）
/// - 需要高亮可建造位置时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 地图块应该渲染为蓝色，表示可建造状态
/// - 蓝色是建造范围的视觉标识，区别于其他范围
/// - 建造结束后应该调用 clear_block 清除高亮
/// - 目前建造范围可能使用黄色（set_can_summon_blocks），此函数可能未完全使用
fn set_build_blocks(position : (Int, Int)) -> Unit {
  msg_info.broadcast({
    type_msg: "set_build_blocks",
    content: ({ "position": position } : Json).stringify(),
  })
}

///|
/// 通知前端清除指定地图块的所有状态（恢复默认状态）
///
/// 该函数用于通知前端清除指定位置地图块的所有状态高亮（绿色、红色、黄色、蓝色），
/// 使其恢复到默认状态（通常是灰色）。函数会发送清除消息到前端，前端应该移除
/// 该位置的所有高亮效果，使地图块回到正常显示状态。这通常用于操作结束后清除
/// 范围显示。
///
/// 参数说明：
/// - position: 要清除状态的地图块位置坐标 (x, y)
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "clear_block"（消息类型标识）
/// - content: JSON字符串，包含 position
///
/// 使用场景：
/// - 移动操作结束后清除移动范围
/// - 攻击操作结束后清除攻击范围
/// - 召唤/建造操作结束后清除范围
/// - 需要清除地图块高亮时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 会清除所有状态高亮（可移动、可攻击、可召唤、可建造）
/// - 清除后地图块应该恢复到默认状态（灰色）
/// - 通常在操作结束后调用，避免范围显示残留
fn clear_block(position : (Int, Int)) -> Unit {
  msg_info.broadcast({
    type_msg: "clear_block",
    content: ({ "position": position } : Json).stringify(),
  })
}

///|
/// 通知前端攻击操作已完成（攻击动画完成消息）
///
/// 该函数用于通知前端指定单位的攻击操作已完成。函数会发送完成消息到前端，
/// 前端应该播放攻击完成动画（如攻击特效、伤害数字等），然后恢复正常状态。
/// 这通常用于同步攻击动画的完成状态，确保前后端状态一致。
///
/// 参数说明：
/// - id: 执行攻击的单位的唯一标识符
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "attack_complete"（消息类型标识）
/// - content: JSON字符串，包含 id
///
/// 使用场景：
/// - 攻击操作执行完成后通知前端
/// - 需要同步攻击动画完成状态时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 前端应该播放攻击完成动画，提升游戏体验
/// - 只有成功攻击（目标不是空）时才发送此消息
/// - 确保在攻击逻辑执行完成后调用
fn attack_complete(id : Int) -> Unit {
  msg_info.broadcast({
    type_msg: "attack_complete",
    content: ({ "id": id } : Json).stringify(),
  })
}

///|
/// 通知前端更新单位血量显示（血条更新消息）
///
/// 该函数用于通知前端更新指定单位的血量显示。函数会将当前血量和最大血量发送
/// 到前端，前端应该更新单位上方的血条显示，反映最新的血量状态。这通常用于
/// 单位受到伤害或治疗后，实时更新血条显示。
///
/// 参数说明：
/// - id: 要更新血量的单位的唯一标识符
/// - now_health: 单位当前血量（Float类型）
/// - max_health: 单位最大血量（Float类型）
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "update_health"（消息类型标识）
/// - content: JSON字符串，包含 id、now_health 和 max_health
///
/// 使用场景：
/// - 单位受到伤害后更新血条
/// - 单位受到治疗后更新血条
/// - 需要实时更新单位血量显示时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 前端应该平滑更新血条，而不是瞬间改变
/// - 血条应该显示在单位上方，方便玩家查看
/// - 确保血量值正确，避免显示错误
fn update_health(id : Int, now_health : Float, max_health : Float) -> Unit {
  msg_info.broadcast({
    type_msg: "update_health",
    content: (
      { "id": id, "now_health": now_health, "max_health": max_health } : Json).stringify(),
  })
}

///|
/// 通知前端游戏结束（游戏失败消息）
///
/// 该函数用于通知前端游戏已结束（失败）。函数会发送游戏结束消息到前端，
/// 前端应该显示游戏失败界面，让玩家知道游戏已经结束。游戏失败通常发生在
/// 所有玩家铜偶被击败时。
///
/// 参数说明：
/// - 无参数
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "game_over"（消息类型标识）
/// - content: JSON字符串，空对象
///
/// 使用场景：
/// - 所有玩家铜偶被击败时
/// - 游戏失败条件满足时
/// - 需要结束游戏时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 前端应该显示游戏失败界面，让玩家知道游戏已结束
/// - 游戏结束后应该阻止玩家继续操作
/// - 确保在清理游戏状态后调用
fn game_over() -> Unit {
  msg_info.broadcast({ type_msg: "game_over", content: ({} : Json).stringify() })
}

///|
/// 通知前端游戏成功（游戏胜利消息）
///
/// 该函数用于通知前端游戏已成功完成（胜利）。函数会发送游戏成功消息到前端，
/// 前端应该显示游戏胜利界面，让玩家知道游戏已经成功完成。游戏胜利通常发生在
/// 玩家完成关卡目标时（如击败所有BOSS）。
///
/// 参数说明：
/// - 无参数
///
/// 返回值：
/// - 返回 Unit 类型（无返回值）
///
/// 消息内容：
/// - type_msg: "success"（消息类型标识）
/// - content: JSON字符串，空对象
///
/// 使用场景：
/// - 玩家完成关卡目标时（如击败所有BOSS）
/// - 游戏胜利条件满足时
/// - 需要显示游戏胜利时
///
/// 注意事项：
/// - 消息会广播到所有前端连接，确保多客户端同步
/// - 前端应该显示游戏胜利界面，让玩家知道游戏已成功
/// - 游戏胜利后应该阻止玩家继续操作
/// - 确保在清理游戏状态后调用
fn success() -> Unit {
  msg_info.broadcast({ type_msg: "success", content: ({} : Json).stringify() })
}
