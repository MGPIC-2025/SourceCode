///|
const K : Float = 1.0

///|
/// 根据攻击力和防御力计算实际造成的伤害值
///
/// 该函数实现了游戏中的伤害计算公式，考虑了攻击力和防御力的相互作用。
/// 伤害计算使用了一个非线性公式，确保防御力能够有效减伤，但不会完全免疫伤害。
/// 公式设计使得高攻击力对高防御力仍然能造成可观伤害，同时低攻击力对高防御力
/// 造成的伤害会显著降低。
///
/// 参数说明：
/// - attack: 攻击者的攻击力数值（必须大于0）
/// - defense: 防御者的防御力数值（可以为0或正数）
///
/// 返回值：
/// - 返回 Float 类型，表示实际造成的伤害值
/// - 伤害值总是小于攻击力（除非防御力为0）
///
/// 伤害计算公式：
/// 1. 首先计算伤害比例：ratio = attack / (attack + K * defense)
///    其中 K 是伤害系数常量，当前值为 1.0
/// 2. 然后计算实际伤害：damage = attack * ratio
/// 3. 完整公式：damage = attack * (attack / (attack + defense))
///
/// 公式特性：
/// - 当防御力为0时，伤害 = 攻击力（无减伤）
/// - 当防御力等于攻击力时，伤害 = 攻击力 / 2（50%减伤）
/// - 当防御力远大于攻击力时，伤害趋近于0（高减伤）
/// - 伤害总是小于攻击力，但永远不会为0（除非攻击力为0）
///
/// 使用场景：
/// - 计算攻击对敌人造成的伤害时
/// - 计算攻击对铜偶造成的伤害时
/// - 计算建筑攻击造成的伤害时
/// - 任何需要计算伤害的场景
///
/// 注意事项：
/// - K 是全局常量，当前值为 1.0，可以通过修改常量调整伤害公式
/// - 公式确保伤害总是小于攻击力，提供防御减伤效果
/// - 如果攻击力为0，伤害也为0
/// - 防御力越高，减伤效果越明显，但不会完全免疫
fn calculate_damage(attack : Float, defense : Float) -> Float {
  let radio = attack / (attack + K * defense)
  attack * radio
}
